%% 2_DOF planar leg kinematics (forward & inverse transforms)
% 本脚本针对一条二自由度串联腿建立 2D 齐次变换矩阵，并提供一个可视化界面：
% 坐标系定义：
%   {0} 基本坐标系：原点在大腿电机轴心，x0 水平向前，y0 竖直向上
%   {1} 大腿坐标系：原点同 {0}，x1 沿大腿连杆方向
%   {2} 小腿坐标系：原点在膝关节（大腿小腿连接点），x2 沿小腿连杆方向
%
% 变量定义：
%   theta_m1  电机一角度（对应theta1，大腿与水平线夹角）
%   theta_m2  电机二角度（对应theta2，大小腿夹角）
%   l1        大腿连杆长度
%   l2        小腿连杆长度
%   theta1    大腿与水平线夹角（{1} 相对于 {0} 的转角）
%   theta2    大小腿夹角（{2} 相对于 {1} 的转角）
%   zu_x      足端在{0}坐标系下的x方向位置
%   zu_y      足端在{0}坐标系下的y方向位置
%
% 输出齐次变换矩阵（2D，3x3）：
%   T01, T12, T02, T21, T10, T20

clear; clc;
fprintf('=== 2-DOF 串联腿 2D 运动学解算（GUI 模式）===\n');
launch2DOFGUI();

%% ===== 局部函数 =====
function launch2DOFGUI()
    % 默认值
    defaults = struct( ...
        'l1',        0.35, ...
        'l2',        0.35, ...
        'theta1',    deg2rad(30), ...
        'theta2',    deg2rad(-45), ...
        'theta_m1',  deg2rad(30), ...
        'theta_m2',  deg2rad(-45), ...
        'zu_x',      0.0, ...
        'zu_y',      0.0);
    
    % 计算初始足端位置
    [zu_x0, zu_y0] = forwardKinematics(defaults.theta_m1, defaults.theta_m2, defaults.l1, defaults.l2);
    defaults.zu_x = zu_x0;
    defaults.zu_y = zu_y0;

    % 创建主窗口（三栏布局）
    fig = figure('Name','2-DOF 串联腿运动学', ...
        'NumberTitle','off', ...
        'MenuBar','none', ...
        'ToolBar','none', ...
        'Resize','on', ...
        'Position',[100 50 1500 800], ...
        'Color',[0.94 0.94 0.94]);

    % ===== 左侧面板：模型初始量 + 矩阵结果 =====
    leftPanel = uipanel(fig, 'Title','模型参数 & 变换矩阵', ...
        'FontWeight','bold', ...
        'FontSize',11, ...
        'BackgroundColor',[0.98 0.98 0.98], ...
        'ForegroundColor',[0.1 0.1 0.4], ...
        'Units','pixels', ...
        'Position',[15 15 400 770]);

    % 模型初始量输入区域
    modelPanel = uipanel('Parent',leftPanel, ...
        'Title','模型初始量', ...
        'FontWeight','bold', ...
        'FontSize',10, ...
        'BackgroundColor',[0.95 0.95 0.98], ...
        'ForegroundColor',[0.1 0.1 0.4], ...
        'Units','pixels', ...
        'Position',[10 520 380 240]);

    modelVars = {'l1','l2','theta1','theta2'};
    modelLabels = {'l_1 (m)', 'l_2 (m)', '\theta_1 (rad)', '\theta_2 (rad)'};
    handles.model = struct();

    for i = 1:numel(modelVars)
        y = 190 - (i-1)*50;
        uicontrol('Parent',modelPanel, ...
            'Style','text', ...
            'String',modelLabels{i}, ...
            'HorizontalAlignment','left', ...
            'FontWeight','bold', ...
            'FontSize',10, ...
            'ForegroundColor',[0.1 0.1 0.4], ...
            'BackgroundColor',[0.95 0.95 0.98], ...
            'Position',[15 y 130 28]);

        handles.model.(modelVars{i}) = uicontrol('Parent',modelPanel, ...
            'Style','edit', ...
            'BackgroundColor','w', ...
            'FontSize',10, ...
            'String',num2str(defaults.(modelVars{i}), '%.6f'), ...
            'Position',[150 y 210 32]);
    end

    uicontrol('Parent',modelPanel, ...
        'Style','pushbutton', ...
        'String','更新矩阵', ...
        'FontWeight','bold', ...
        'FontSize',11, ...
        'BackgroundColor',[0.2 0.5 0.8], ...
        'ForegroundColor','w', ...
        'Position',[100 15 180 40], ...
        'Callback',@onUpdateMatrices);

    % 矩阵结果显示区域
    handles.matrixBox = uicontrol('Parent',leftPanel, ...
        'Style','edit', ...
        'Max',20,'Min',0, ...
        'Enable','inactive', ...
        'HorizontalAlignment','left', ...
        'BackgroundColor',[1 1 1], ...
        'Position',[10 15 380 490], ...
        'String','等待计算...', ...
        'FontName','Courier New', ...
        'FontSize',9);

    % ===== 中间面板：可视化 =====
    visPanel = uipanel(fig, 'Title','可视化', ...
        'FontWeight','bold', ...
        'FontSize',11, ...
        'BackgroundColor',[0.98 0.98 0.98], ...
        'ForegroundColor',[0.1 0.1 0.4], ...
        'Units','pixels', ...
        'Position',[430 15 550 770]);
    
    ax = axes('Parent',visPanel, ...
        'Units','pixels', ...
        'Position',[20 50 510 700], ...
        'Color',[1 1 1]);
    grid(ax,'on'); axis(ax,'equal');
    xlabel(ax,'X / m', 'FontSize',11, 'FontWeight','bold');
    ylabel(ax,'Y / m', 'FontSize',11, 'FontWeight','bold');
    title(ax,'串联腿模型可视化', 'FontSize',12, 'FontWeight','bold'); 
    hold(ax,'on');

    % ===== 右侧面板：实时数据修改 =====
    rightPanel = uipanel(fig, 'Title','实时数据修改', ...
        'FontWeight','bold', ...
        'FontSize',11, ...
        'BackgroundColor',[0.98 0.98 0.98], ...
        'ForegroundColor',[0.1 0.1 0.4], ...
        'Units','pixels', ...
        'Position',[1000 15 480 770]);

    % 电机角度输入
    motorPanel = uipanel('Parent',rightPanel, ...
        'Title','电机角度输入（正解）', ...
        'FontWeight','bold', ...
        'FontSize',10, ...
        'BackgroundColor',[0.95 0.98 0.95], ...
        'ForegroundColor',[0.1 0.4 0.1], ...
        'Units','pixels', ...
        'Position',[10 580 460 180]);

    handles.motor = struct();
    motorVars = {'theta_m1','theta_m2'};
    motorLabels = {'\theta_{m1} (rad)', '\theta_{m2} (rad)'};

    for i = 1:numel(motorVars)
        y = 140 - (i-1)*65;
        uicontrol('Parent',motorPanel, ...
            'Style','text', ...
            'String',motorLabels{i}, ...
            'HorizontalAlignment','left', ...
            'FontWeight','bold', ...
            'FontSize',10, ...
            'ForegroundColor',[0.1 0.4 0.1], ...
            'BackgroundColor',[0.95 0.98 0.95], ...
            'Position',[15 y 150 28]);

        handles.motor.(motorVars{i}) = uicontrol('Parent',motorPanel, ...
            'Style','edit', ...
            'BackgroundColor','w', ...
            'FontSize',10, ...
            'String',num2str(defaults.(motorVars{i}), '%.6f'), ...
            'Position',[170 y 260 32], ...
            'Callback',@onMotorInput);
    end

    uicontrol('Parent',motorPanel, ...
        'Style','pushbutton', ...
        'String','正解：计算足端位置', ...
        'FontWeight','bold', ...
        'FontSize',11, ...
        'BackgroundColor',[0.2 0.7 0.3], ...
        'ForegroundColor','w', ...
        'Position',[100 15 280 40], ...
        'Callback',@onForwardKinematics);

    % 足端位置输入
    footPanel = uipanel('Parent',rightPanel, ...
        'Title','足端位置输入（逆解）', ...
        'FontWeight','bold', ...
        'FontSize',10, ...
        'BackgroundColor',[0.98 0.95 0.95], ...
        'ForegroundColor',[0.4 0.1 0.1], ...
        'Units','pixels', ...
        'Position',[10 380 460 190]);

    handles.foot = struct();
    footVars = {'zu_x','zu_y'};
    footLabels = {'z_u_x (m)', 'z_u_y (m)'};

    for i = 1:numel(footVars)
        y = 150 - (i-1)*65;
        uicontrol('Parent',footPanel, ...
            'Style','text', ...
            'String',footLabels{i}, ...
            'HorizontalAlignment','left', ...
            'FontWeight','bold', ...
            'FontSize',10, ...
            'ForegroundColor',[0.4 0.1 0.1], ...
            'BackgroundColor',[0.98 0.95 0.95], ...
            'Position',[15 y 150 28]);

        handles.foot.(footVars{i}) = uicontrol('Parent',footPanel, ...
            'Style','edit', ...
            'BackgroundColor','w', ...
            'FontSize',10, ...
            'String',num2str(defaults.(footVars{i}), '%.6f'), ...
            'Position',[170 y 260 32], ...
            'Callback',@onFootInput);
    end

    uicontrol('Parent',footPanel, ...
        'Style','pushbutton', ...
        'String','逆解：计算电机角度', ...
        'FontWeight','bold', ...
        'FontSize',11, ...
        'BackgroundColor',[0.7 0.2 0.2], ...
        'ForegroundColor','w', ...
        'Position',[100 15 280 40], ...
        'Callback',@onInverseKinematics);

    % 结果显示区域
    handles.resultBox = uicontrol('Parent',rightPanel, ...
        'Style','edit', ...
        'Max',10,'Min',0, ...
        'Enable','inactive', ...
        'HorizontalAlignment','left', ...
        'BackgroundColor',[1 1 1], ...
        'Position',[10 15 460 350], ...
        'String','等待计算...', ...
        'FontName','Courier New', ...
        'FontSize',9);

    % 存储handles到figure的UserData
    handles.ax = ax;
    handles.fig = fig;
    set(fig, 'UserData', handles);

    % 初始化显示
    updateAll(handles, defaults);

    % ===== 回调函数 =====
    function onUpdateMatrices(~,~)
        handles = get(fig, 'UserData');
        values = readModelInputs(handles.model);
        if isempty(values)
            return;
        end
        displayMatrices(handles.matrixBox, values);
    end

    function onMotorInput(~,~)
        % 电机输入改变时，标记需要正解
    end

    function onFootInput(~,~)
        % 足端输入改变时，标记需要逆解
    end

    function onForwardKinematics(~,~)
        handles = get(fig, 'UserData');
        motorVals = readMotorInputs(handles.motor);
        modelVals = readModelInputs(handles.model);
        if isempty(motorVals) || isempty(modelVals)
            return;
        end
        
        try
            [zu_x, zu_y] = forwardKinematics(motorVals.theta_m1, motorVals.theta_m2, ...
                                             modelVals.l1, modelVals.l2);
            
            set(handles.foot.zu_x, 'String', num2str(zu_x, '%.6f'));
            set(handles.foot.zu_y, 'String', num2str(zu_y, '%.6f'));
            
            % 更新theta1和theta2用于显示
            values = struct();
            values.l1 = modelVals.l1;
            values.l2 = modelVals.l2;
            values.theta1 = motorVals.theta_m1;
            values.theta2 = motorVals.theta_m2;
            values.zu_x = zu_x;
            values.zu_y = zu_y;
            
            updateVisualization(handles, values);
            updateResultDisplay(handles, values, '正解');
            displayMatrices(handles.matrixBox, values);
            
            % 成功提示
            msgbox(sprintf('正解计算成功！\n足端位置: (%.6f, %.6f) m', zu_x, zu_y), ...
                   '正解完成', 'help');
        catch ME
            errordlg(sprintf('正解计算失败：%s', ME.message), '计算错误');
        end
    end

    function onInverseKinematics(~,~)
        handles = get(fig, 'UserData');
        footVals = readFootInputs(handles.foot);
        modelVals = readModelInputs(handles.model);
        if isempty(footVals) || isempty(modelVals)
            return;
        end
        
        try
            [theta_m1, theta_m2, valid] = inverseKinematics(footVals.zu_x, footVals.zu_y, ...
                                                            modelVals.l1, modelVals.l2);
            
            if ~valid
                r = sqrt(footVals.zu_x^2 + footVals.zu_y^2);
                max_r = modelVals.l1 + modelVals.l2;
                min_r = abs(modelVals.l1 - modelVals.l2);
                errordlg(sprintf(['逆解无解：目标位置超出工作空间！\n\n' ...
                                 '目标半径: %.6f m\n' ...
                                 '工作空间: [%.6f, %.6f] m'], ...
                                 r, min_r, max_r), '逆解错误');
                return;
            end
            
            set(handles.motor.theta_m1, 'String', num2str(theta_m1, '%.6f'));
            set(handles.motor.theta_m2, 'String', num2str(theta_m2, '%.6f'));
            
            % 更新theta1和theta2用于显示
            values = struct();
            values.l1 = modelVals.l1;
            values.l2 = modelVals.l2;
            values.theta1 = theta_m1;
            values.theta2 = theta_m2;
            values.zu_x = footVals.zu_x;
            values.zu_y = footVals.zu_y;
            
            updateVisualization(handles, values);
            updateResultDisplay(handles, values, '逆解');
            displayMatrices(handles.matrixBox, values);
            
            % 成功提示
            msgbox(sprintf('逆解计算成功！\n电机角度: θ_m1=%.6f rad, θ_m2=%.6f rad', ...
                   theta_m1, theta_m2), '逆解完成', 'help');
        catch ME
            errordlg(sprintf('逆解计算失败：%s', ME.message), '计算错误');
        end
    end

    function updateAll(handles, values)
        displayMatrices(handles.matrixBox, values);
        updateVisualization(handles, values);
        updateResultDisplay(handles, values, '初始');
    end

    function updateVisualization(handles, values)
        drawLeg(handles.ax, values);
    end

    function updateResultDisplay(handles, values, mode)
        textContent = sprintf([ ...
            '═══════════════════════════════════\n' ...
            '计算模式: %s\n' ...
            '═══════════════════════════════════\n\n' ...
            '【电机角度】\n' ...
            '  θ_m1 = %8.6f rad  (%7.2f°)\n' ...
            '  θ_m2 = %8.6f rad  (%7.2f°)\n\n' ...
            '【足端位置】\n' ...
            '  z_u_x = %8.6f m\n' ...
            '  z_u_y = %8.6f m\n\n' ...
            '【模型参数】\n' ...
            '  l1     = %8.6f m\n' ...
            '  l2     = %8.6f m\n' ...
            '  θ1     = %8.6f rad  (%7.2f°)\n' ...
            '  θ2     = %8.6f rad  (%7.2f°)\n\n' ...
            '【工作空间】\n' ...
            '  最大半径: %.6f m\n' ...
            '  最小半径: %.6f m\n' ...
            '  当前半径: %.6f m\n'], ...
            mode, ...
            values.theta1, rad2deg(values.theta1), ...
            values.theta2, rad2deg(values.theta2), ...
            values.zu_x, values.zu_y, ...
            values.l1, values.l2, ...
            values.theta1, rad2deg(values.theta1), ...
            values.theta2, rad2deg(values.theta2), ...
            values.l1 + values.l2, ...
            abs(values.l1 - values.l2), ...
            sqrt(values.zu_x^2 + values.zu_y^2));
        set(handles.resultBox, 'String', textContent);
    end
end

function values = readModelInputs(handles)
    fields = fieldnames(handles);
    values = struct();
    for i = 1:numel(fields)
        raw = get(handles.(fields{i}), 'String');
        val = str2double(raw);
        if isnan(val)
            errordlg(sprintf('模型参数 "%s" 输入无效：%s', fields{i}, raw), '输入错误');
            values = [];
            return;
        end
        values.(fields{i}) = val;
    end
end

function values = readMotorInputs(handles)
    fields = fieldnames(handles);
    values = struct();
    for i = 1:numel(fields)
        raw = get(handles.(fields{i}), 'String');
        val = str2double(raw);
        if isnan(val)
            errordlg(sprintf('电机参数 "%s" 输入无效：%s', fields{i}, raw), '输入错误');
            values = [];
            return;
        end
        values.(fields{i}) = val;
    end
end

function values = readFootInputs(handles)
    fields = fieldnames(handles);
    values = struct();
    for i = 1:numel(fields)
        raw = get(handles.(fields{i}), 'String');
        val = str2double(raw);
        if isnan(val)
            errordlg(sprintf('足端参数 "%s" 输入无效：%s', fields{i}, raw), '输入错误');
            values = [];
            return;
        end
        values.(fields{i}) = val;
    end
end

%% ===== 运动学正解 =====
function [zu_x, zu_y] = forwardKinematics(theta_m1, theta_m2, l1, l2)
    % 运动学正解：从电机角度计算足端位置
    % 输入：
    %   theta_m1: 电机一角度（对应theta1）
    %   theta_m2: 电机二角度（对应theta2）
    %   l1: 大腿连杆长度
    %   l2: 小腿连杆长度
    % 输出：
    %   zu_x: 足端在{0}坐标系下的x位置
    %   zu_y: 足端在{0}坐标系下的y位置
    
    theta1 = theta_m1;
    theta2 = theta_m2;
    
    % 使用齐次变换矩阵计算足端位置
    % 足端在{2}坐标系中的位置是 [l2; 0; 1]
    % 需要变换到{0}坐标系
    R = @(theta) [cos(theta), -sin(theta);
                  sin(theta),  cos(theta)];
    
    % T01: {1} -> {0}
    T01 = [R(theta1), [0; 0];
           0, 0, 1];
    
    % T12: {2} -> {1}
    T12 = [R(theta2), [l1; 0];
           0, 0, 1];
    
    % T02: {2} -> {0}
    T02 = T01 * T12;
    
    % 足端在{2}系中的位置
    foot_in_2 = [l2; 0; 1];
    
    % 变换到{0}系
    foot_in_0 = T02 * foot_in_2;
    
    zu_x = foot_in_0(1);
    zu_y = foot_in_0(2);
end

%% ===== 运动学逆解 =====
function [theta_m1, theta_m2, valid] = inverseKinematics(zu_x, zu_y, l1, l2)
    % 运动学逆解：从足端位置计算电机角度
    % 输入：
    %   zu_x: 足端在{0}坐标系下的x位置
    %   zu_y: 足端在{0}坐标系下的y位置
    %   l1: 大腿连杆长度
    %   l2: 小腿连杆长度
    % 输出：
    %   theta_m1: 电机一角度（对应theta1）
    %   theta_m2: 电机二角度（对应theta2）
    %   valid: 是否有解（目标位置是否在工作空间内）
    
    % 计算到原点的距离
    r = sqrt(zu_x^2 + zu_y^2);
    
    % 检查是否在工作空间内
    if r > (l1 + l2) || r < abs(l1 - l2)
        theta_m1 = 0;
        theta_m2 = 0;
        valid = false;
        return;
    end
    
    valid = true;
    
    % 使用余弦定理计算theta2
    % r^2 = l1^2 + l2^2 - 2*l1*l2*cos(pi - theta2)
    % r^2 = l1^2 + l2^2 + 2*l1*l2*cos(theta2)
    cos_theta2 = (r^2 - l1^2 - l2^2) / (2 * l1 * l2);
    cos_theta2 = max(-1, min(1, cos_theta2)); % 限制在[-1, 1]范围内
    theta2 = acos(cos_theta2);
    
    % 计算theta1
    % 先计算从原点到目标点的角度
    alpha = atan2(zu_y, zu_x);
    
    % 计算从原点到膝关节的角度
    % 使用余弦定理：l2^2 = l1^2 + r^2 - 2*l1*r*cos(beta)
    cos_beta = (l1^2 + r^2 - l2^2) / (2 * l1 * r);
    cos_beta = max(-1, min(1, cos_beta));
    beta = acos(cos_beta);
    
    % theta1 = alpha - beta（肘部向下配置）
    % 或者 theta1 = alpha + beta（肘部向上配置）
    % 这里选择肘部向下配置
    theta1 = alpha - beta;
    
    theta_m1 = theta1;
    theta_m2 = theta2;
end

function drawLeg(ax, values)
    theta1 = values.theta1;
    theta2 = values.theta2;
    l1 = values.l1;
    l2 = values.l2;

    hip   = [0; 0];
    knee  = hip + [l1 * cos(theta1); l1 * sin(theta1)];
    ankle = knee + [l2 * cos(theta1 + theta2); l2 * sin(theta1 + theta2)];

    cla(ax); hold(ax,'on'); grid(ax,'on'); axis(ax,'equal');
    set(ax, 'GridAlpha', 0.3, 'GridColor', [0.5 0.5 0.5]);
    
    % 绘制工作空间边界（可选）
    max_r = l1 + l2;
    min_r = abs(l1 - l2);
    theta_ws = linspace(0, 2*pi, 100);
    x_ws_max = max_r * cos(theta_ws);
    y_ws_max = max_r * sin(theta_ws);
    x_ws_min = min_r * cos(theta_ws);
    y_ws_min = min_r * sin(theta_ws);
    plot(ax, x_ws_max, y_ws_max, '--', 'Color', [0.7 0.7 0.9], 'LineWidth', 1.5);
    if min_r > 0.01
        plot(ax, x_ws_min, y_ws_min, '--', 'Color', [0.9 0.7 0.7], 'LineWidth', 1.5);
    end
    
    % 绘制地面线
    x_ground = [-0.5, max(0.8, ankle(1)+0.3)];
    line(ax, x_ground, [0 0], 'LineStyle','--','Color',[0.4 0.4 0.4], 'LineWidth',2);
    text(ax, mean(x_ground), -0.05, '地面', 'HorizontalAlignment','center', ...
         'FontSize',9, 'Color',[0.4 0.4 0.4], 'FontWeight','bold');
    
    % 绘制连杆（更粗更明显）
    plot(ax, [hip(1) knee(1)], [hip(2) knee(2)], 'LineWidth',6,'Color',[0.1 0.3 0.7], ...
         'DisplayName','大腿 (l_1)');
    plot(ax, [knee(1) ankle(1)], [knee(2) ankle(2)], 'LineWidth',6,'Color',[0.7 0.3 0.1], ...
         'DisplayName','小腿 (l_2)');
    
    % 绘制关节点（更大更明显）
    scatter(ax, hip(1), hip(2), 120, 'filled','MarkerFaceColor',[0 0.7 0.2], ...
            'MarkerEdgeColor','k','LineWidth',2.5, 'DisplayName','髋关节');
    scatter(ax, knee(1), knee(2), 120, 'filled','MarkerFaceColor',[0.7 0 0.7], ...
            'MarkerEdgeColor','k','LineWidth',2.5, 'DisplayName','膝关节');
    scatter(ax, ankle(1), ankle(2), 120, 'filled','MarkerFaceColor',[0.9 0.2 0.2], ...
            'MarkerEdgeColor','k','LineWidth',2.5, 'DisplayName','足端');
    
    % 绘制坐标系箭头 {0}
    arrow_len = 0.15;
    quiver(ax, hip(1), hip(2), arrow_len, 0, 0, 'Color',[0.8 0 0], 'LineWidth',2, ...
           'MaxHeadSize',8, 'AutoScale','off', 'DisplayName','x_0');
    quiver(ax, hip(1), hip(2), 0, arrow_len, 0, 'Color',[0 0.8 0], 'LineWidth',2, ...
           'MaxHeadSize',8, 'AutoScale','off', 'DisplayName','y_0');
    text(ax, hip(1)+arrow_len+0.02, hip(2), 'x_0', 'FontSize',9, 'Color',[0.8 0 0], ...
         'FontWeight','bold');
    text(ax, hip(1), hip(2)+arrow_len+0.02, 'y_0', 'FontSize',9, 'Color',[0 0.8 0], ...
         'FontWeight','bold');
    
    % 绘制坐标系箭头 {1}
    x1_dir = [cos(theta1); sin(theta1)];
    y1_dir = [-sin(theta1); cos(theta1)];
    quiver(ax, hip(1), hip(2), arrow_len*x1_dir(1), arrow_len*x1_dir(2), 0, ...
           'Color',[0.6 0 0.6], 'LineWidth',2, 'MaxHeadSize',8, 'AutoScale','off', ...
           'LineStyle','--', 'DisplayName','x_1');
    quiver(ax, hip(1), hip(2), arrow_len*y1_dir(1), arrow_len*y1_dir(2), 0, ...
           'Color',[0 0.6 0.6], 'LineWidth',2, 'MaxHeadSize',8, 'AutoScale','off', ...
           'LineStyle','--', 'DisplayName','y_1');
    
    % 绘制坐标系箭头 {2}
    theta_total = theta1 + theta2;
    x2_dir = [cos(theta_total); sin(theta_total)];
    y2_dir = [-sin(theta_total); cos(theta_total)];
    quiver(ax, knee(1), knee(2), arrow_len*x2_dir(1), arrow_len*x2_dir(2), 0, ...
           'Color',[0.4 0 0.4], 'LineWidth',2, 'MaxHeadSize',8, 'AutoScale','off', ...
           'LineStyle',':', 'DisplayName','x_2');
    quiver(ax, knee(1), knee(2), arrow_len*y2_dir(1), arrow_len*y2_dir(2), 0, ...
           'Color',[0 0.4 0.4], 'LineWidth',2, 'MaxHeadSize',8, 'AutoScale','off', ...
           'LineStyle',':', 'DisplayName','y_2');
    
    % 标注坐标系
    text(ax, hip(1), hip(2)-0.08, '{0}/{1}', 'HorizontalAlignment','center', ...
         'FontSize',11, 'FontWeight','bold', 'BackgroundColor',[1 1 1 0.8], ...
         'EdgeColor',[0.3 0.3 0.3]);
    text(ax, knee(1), knee(2)+0.08, '{2}', 'HorizontalAlignment','center', ...
         'FontSize',11, 'FontWeight','bold', 'BackgroundColor',[1 1 1 0.8], ...
         'EdgeColor',[0.3 0.3 0.3]);
    
    % 标注足端位置
    if isfield(values, 'zu_x') && isfield(values, 'zu_y')
        text(ax, ankle(1)+0.08, ankle(2)+0.05, ...
             sprintf('足端\n(%.3f, %.3f)', values.zu_x, values.zu_y), ...
             'FontSize',9, 'Color',[0.6 0 0], 'FontWeight','bold', ...
             'BackgroundColor',[1 1 1 0.9], 'EdgeColor',[0.5 0 0], ...
             'HorizontalAlignment','left');
    end
    
    % 标注角度
    arc_radius = 0.1;
    arc_theta = linspace(0, theta1, 20);
    arc_x = arc_radius * cos(arc_theta);
    arc_y = arc_radius * sin(arc_theta);
    plot(ax, arc_x, arc_y, 'Color',[0.3 0.3 0.8], 'LineWidth',1.5);
    text(ax, arc_radius*cos(theta1/2)*1.3, arc_radius*sin(theta1/2)*1.3, ...
         sprintf('θ₁=%.1f°', rad2deg(theta1)), 'FontSize',8, 'Color',[0.3 0.3 0.8]);
    
    if abs(theta2) > 0.01
        arc_theta2 = linspace(theta1, theta1+theta2, 20);
        arc_x2 = knee(1) + arc_radius * cos(arc_theta2);
        arc_y2 = knee(2) + arc_radius * sin(arc_theta2);
        plot(ax, arc_x2, arc_y2, 'Color',[0.8 0.3 0.3], 'LineWidth',1.5);
        mid_theta = theta1 + theta2/2;
        text(ax, knee(1)+arc_radius*cos(mid_theta)*1.3, ...
             knee(2)+arc_radius*sin(mid_theta)*1.3, ...
             sprintf('θ₂=%.1f°', rad2deg(theta2)), 'FontSize',8, 'Color',[0.8 0.3 0.3]);
    end

    % 设置坐标轴范围
    margin = 0.2;
    xlim(ax, [-0.5, max(0.8, ankle(1)+margin)]);
    ylim(ax, [min(-0.3, ankle(2)-margin), max(0.8, ankle(2)+margin)]);

    title(ax, sprintf('\\theta_1 = %.2f° (%.4f rad), \\theta_2 = %.2f° (%.4f rad)', ...
          rad2deg(theta1), theta1, rad2deg(theta2), theta2), ...
          'FontSize',12, 'FontWeight','bold');
end

function displayMatrices(resultBox, values)
    [T01, T12, T02, T21, T10, T20] = computeTransforms(values.theta1, values.theta2, values.l1);
    textContent = sprintf([ ...
        '═══════════════════════════════════════\n' ...
        '  齐次变换矩阵（3×3）\n' ...
        '═══════════════════════════════════════\n\n' ...
        '%s%s%s%s%s%s'], ...
        matrixBlock('T01', T01, '{1} → {0}'), ...
        matrixBlock('T12', T12, '{2} → {1}'), ...
        matrixBlock('T02', T02, '{2} → {0}'), ...
        matrixBlock('T21', T21, '{1} → {2}'), ...
        matrixBlock('T10', T10, '{0} → {1}'), ...
        matrixBlock('T20', T20, '{0} → {2}'));
    set(resultBox, 'String', textContent);
    fprintf('\n最新矩阵计算结果：\n%s\n', textContent);
end

function [T01, T12, T02, T21, T10, T20] = computeTransforms(theta1, theta2, l1)
    R = @(theta) [cos(theta), -sin(theta);
                  sin(theta),  cos(theta)];

    T01 = [R(theta1), [0; 0];
           0, 0, 1];

    T12 = [R(theta2), [l1; 0];
           0, 0, 1];

    T02 = T01 * T12;

    T10 = inv(T01);
    T21 = inv(T12);
    T20 = inv(T02);
end

function txt = matrixBlock(name, M, desc)
    if nargin < 3
        desc = '';
    end
    rowFmt = '[% 8.4f  % 8.4f  % 8.4f]';
    rows = arrayfun(@(idx) sprintf(rowFmt, M(idx, :)), 1:3, 'UniformOutput', false);
    if ~isempty(desc)
        txt = sprintf('%s (%s):\n%s\n%s\n%s\n\n', name, desc, rows{:});
    else
        txt = sprintf('%s:\n%s\n%s\n%s\n\n', name, rows{:});
    end
end
